/**
 * Tests de integraciÃ³n para repositorios MongoDB - VersiÃ³n Mock
 * 
 * Esta versiÃ³n utiliza mocks en lugar de MongoDB real para evitar problemas
 * de descarga de binarios en entornos CI/CD con restricciones de red.
 */

import { Test, TestingModule } from '@nestjs/testing';
import { MongooseModule, getModelToken } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import {
  ChatSchema,
  ChatSchemaDefinition,
  ChatDocument,
} from '../../schemas/chat.schema';
import {
  MessageSchema,
  MessageSchemaDefinition,
  MessageDocument,
} from '../../schemas/message.schema';
import { ChatMapper } from '../../mappers/chat.mapper';
import { MessageMapper } from '../../mappers/message.mapper';
import { MongoChatRepositoryImpl } from '../impl/mongo-chat.repository.impl';
import { MongoMessageRepositoryImpl } from '../impl/mongo-message.repository.simple';
import { Chat } from '../../../domain/entities/chat';
import { Message } from '../../../domain/entities/message';
import { ChatId } from '../../../domain/value-objects/chat-id';
import { MessageId } from '../../../domain/value-objects/message-id';
import { VisitorId } from '../../../domain/value-objects/visitor-id';
import { Uuid } from 'src/context/shared/domain/value-objects/uuid';

// Mock para MongoDB - Simula el comportamiento de la base de datos con queries complejas
const createMockModel = () => {
  const mockModel = {
    create: jest.fn(),
    findOne: jest.fn(),
    find: jest.fn(),
    findById: jest.fn(),
    updateOne: jest.fn(),
    deleteOne: jest.fn(),
    deleteMany: jest.fn(),
    countDocuments: jest.fn(),
    save: jest.fn(),
    aggregate: jest.fn(),
  };

  // Configurar chainable methods para queries complejas
  const chainableMethods = {
    sort: jest.fn().mockReturnThis(),
    limit: jest.fn().mockReturnThis(),
    skip: jest.fn().mockReturnThis(),
    exec: jest.fn(),
  };

  // Asignar mÃ©todos encadenables
  Object.assign(mockModel, chainableMethods);
  mockModel.find.mockReturnValue(chainableMethods);
  mockModel.findOne.mockReturnValue(chainableMethods);

  return mockModel;
};

describe('MongoDB Integration Tests - Mock Version', () => {
  let module: TestingModule;
  let chatRepository: MongoChatRepositoryImpl;
  let messageRepository: MongoMessageRepositoryImpl;
  let chatModelMock: any;
  let messageModelMock: any;

  beforeAll(async () => {
    console.log('ðŸ”§ Iniciando tests con MongoDB simulado...');
    
    // Crear mocks para los modelos
    chatModelMock = createMockModel();
    messageModelMock = createMockModel();
    
    // Configurar el mÃ³dulo de testing con providers mockeados
    module = await Test.createTestingModule({
      providers: [
        ChatMapper,
        MessageMapper,
        MongoChatRepositoryImpl,
        MongoMessageRepositoryImpl,
        {
          provide: getModelToken(ChatSchema.name),
          useValue: chatModelMock,
        },
        {
          provide: getModelToken(MessageSchema.name),
          useValue: messageModelMock,
        },
      ],
    }).compile();

    // Obtener instancias
    chatRepository = module.get<MongoChatRepositoryImpl>(MongoChatRepositoryImpl);
    messageRepository = module.get<MongoMessageRepositoryImpl>(MongoMessageRepositoryImpl);
    
    console.log('âœ… MÃ³dulo de testing con mocks configurado correctamente');
  });

  afterAll(async () => {
    if (module) {
      await module.close();
    }
  });

  beforeEach(() => {
    // Limpiar todos los mocks antes de cada test
    jest.clearAllMocks();
  });

  describe('ConfiguraciÃ³n y Conectividad (Mock)', () => {
    it('deberÃ­a tener todas las dependencias inyectadas correctamente', () => {
      expect(chatRepository).toBeDefined();
      expect(messageRepository).toBeDefined();
      expect(chatModelMock).toBeDefined();
      expect(messageModelMock).toBeDefined();
    });

    it('deberÃ­a poder limpiar colecciones (simulado)', async () => {
      chatModelMock.deleteMany.mockResolvedValue({ deletedCount: 0 });
      messageModelMock.deleteMany.mockResolvedValue({ deletedCount: 0 });

      await chatModelMock.deleteMany({});
      await messageModelMock.deleteMany({});

      expect(chatModelMock.deleteMany).toHaveBeenCalledWith({});
      expect(messageModelMock.deleteMany).toHaveBeenCalledWith({});
    });
  });

  describe('IntegraciÃ³n Chat Repository - MongoDB Mock', () => {
    it('deberÃ­a guardar un chat completo', async () => {
      // Arrange - Crear datos del chat
      const chatId = ChatId.create();
      const visitorId = VisitorId.create(Uuid.random().value);
      const commercialId1 = Uuid.random().value;
      const commercialId2 = Uuid.random().value;

      const chat = Chat.fromPrimitives({
        id: chatId.value,
        status: 'PENDING',
        priority: 'HIGH',
        visitorId: visitorId.value,
        availableCommercialIds: [commercialId1, commercialId2],
        visitorInfo: {
          name: 'Juan PÃ©rez',
          email: 'juan@example.com',
          phone: '+34600000000',
          location: {
            country: 'EspaÃ±a',
            city: 'Barcelona',
          },
          company: 'ABC Corp',
        },
        metadata: {
          department: 'Ventas',
          source: 'web',
          tags: ['priority', 'high'],
          customFields: { campaign: 'summer2024' },
        },
        createdAt: new Date(),
        updatedAt: new Date(),
        totalMessages: 0,
      });

      // Mock del save
      const mockSavedDoc = {
        id: chatId.value,
        status: 'PENDING',
        priority: 'HIGH',
        visitorInfo: { name: 'Juan PÃ©rez' },
        metadata: { department: 'Ventas' },
        isActive: true,
      };
      chatModelMock.create.mockResolvedValue(mockSavedDoc);

      // Act - Guardar usando el repositorio
      const saveResult = await chatRepository.save(chat);

      // Assert - Verificar guardado exitoso
      expect(saveResult.isOk()).toBe(true);
      expect(chatModelMock.create).toHaveBeenCalled();
    });

    it('deberÃ­a recuperar un chat por ID', async () => {
      // Arrange - Preparar datos mock
      const testChatId = Uuid.random().value;
      const testVisitorId = Uuid.random().value;
      const testCommercialId = Uuid.random().value;

      const mockChat = {
        id: testChatId,
        status: 'ASSIGNED',
        priority: 'NORMAL',
        visitorId: testVisitorId,
        assignedCommercialId: testCommercialId,
        availableCommercialIds: [testCommercialId],
        visitorInfo: {
          id: testVisitorId,
          name: 'MarÃ­a GarcÃ­a',
          email: 'maria@example.com',
          phone: '+34600000000',
          location: 'Madrid, EspaÃ±a',
          additionalData: {
            company: 'Cliente Test',
          },
        },
        metadata: {
          department: 'soporte',
          source: 'phone',
        },
        department: 'soporte',
        totalMessages: 3,
        isActive: true,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      chatModelMock.findOne.mockResolvedValue(mockChat);

      // Act - Recuperar usando el repositorio
      const foundResult = await chatRepository.findById(ChatId.create(testChatId));

      // Assert - Verificar que se recuperÃ³ correctamente
      expect(foundResult.isOk()).toBe(true);
      const foundChat = foundResult.unwrap();
      expect(foundChat.id.value).toBe(testChatId);
      expect(foundChat.status.value).toBe('ASSIGNED');
      expect(chatModelMock.findOne).toHaveBeenCalledWith({ id: testChatId });
    });

    it('deberÃ­a manejar error cuando el chat no existe', async () => {
      // Arrange
      const nonExistentId = Uuid.random().value;
      chatModelMock.findOne.mockResolvedValue(null);

      // Act
      const result = await chatRepository.findById(ChatId.create(nonExistentId));

      // Assert
      expect(result.isErr()).toBe(true);
      expect(chatModelMock.findOne).toHaveBeenCalledWith({ id: nonExistentId });
    });
  });

  describe('IntegraciÃ³n Message Repository - MongoDB Mock', () => {
    let testChatId: string;

    beforeEach(() => {
      testChatId = Uuid.random().value;
    });

    it('deberÃ­a guardar un mensaje', async () => {
      // Arrange - Crear mensaje de dominio
      const senderId = Uuid.random().value;
      const message = Message.createTextMessage({
        chatId: testChatId,
        senderId,
        content: 'Hola, necesito ayuda con mi pedido',
        isInternal: false,
        isFirstResponse: true,
      });

      // Mock para obtener el Ãºltimo mensaje (sequenceNumber)
      const chainableMock = {
        sort: jest.fn().mockReturnThis(),
        exec: jest.fn().mockResolvedValue(null), // No hay mensajes previos
      };
      messageModelMock.findOne.mockReturnValue(chainableMock);

      const mockSavedMessage = {
        id: message.id.value,
        chatId: testChatId,
        content: { text: 'Hola, necesito ayuda con mi pedido' },
        senderId,
        isInternal: false,
        isFirstResponse: true,
        sequenceNumber: 1,
      };
      messageModelMock.create.mockResolvedValue(mockSavedMessage);

      // Act - Guardar mensaje
      const saveResult = await messageRepository.save(message);

      // Debug information if test fails
      if (saveResult.isErr()) {
        console.log('Error al guardar mensaje:', saveResult.error.message);
      }

      // Assert - Verificar guardado exitoso
      expect(saveResult.isOk()).toBe(true);
      expect(messageModelMock.findOne).toHaveBeenCalledWith({ chatId: testChatId });
      expect(messageModelMock.create).toHaveBeenCalled();
    });

    it('deberÃ­a recuperar mensajes por chat ID', async () => {
      // Arrange - Preparar mensajes mock
      const mockMessages = Array.from({ length: 5 }, (_, i) => ({
        id: Uuid.random().value,
        chatId: testChatId,
        senderId: 'test-sender',
        content: { text: `Mensaje nÃºmero ${i + 1}` },
        isInternal: false,
        isFirstResponse: i === 0,
        createdAt: new Date(),
        sequenceNumber: i + 1,
      }));

      // Configurar el mock para queries encadenadas
      const chainableMock = {
        sort: jest.fn().mockReturnThis(),
        limit: jest.fn().mockReturnThis(),
        skip: jest.fn().mockReturnThis(),
        exec: jest.fn().mockResolvedValue(mockMessages),
      };
      
      messageModelMock.find.mockReturnValue(chainableMock);
      messageModelMock.countDocuments.mockResolvedValue(5);

      // Act - Recuperar mensajes por chat
      const result = await messageRepository.findByChatId(
        ChatId.create(testChatId),
        undefined,
        undefined,
        10,
        0,
      );

      // Debug information if test fails
      if (result.isErr()) {
        console.log('Error al recuperar mensajes:', result.error.message);
      }

      // Assert - Verificar recuperaciÃ³n
      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        const searchResult = result.unwrap();
        expect(searchResult.messages).toHaveLength(5);
        expect(searchResult.total).toBe(5);
      }
      expect(messageModelMock.find).toHaveBeenCalledWith({ chatId: testChatId, isDeleted: false });
    });

    it('deberÃ­a obtener el Ãºltimo mensaje de un chat', async () => {
      // Arrange - Preparar Ãºltimo mensaje mock
      const mockLastMessage = {
        id: Uuid.random().value,
        chatId: testChatId,
        senderId: 'test-sender',
        content: { text: 'Mensaje mÃ¡s reciente' },
        isInternal: false,
        isFirstResponse: false,
        createdAt: new Date(),
        sequenceNumber: 3,
      };

      // Configurar mock para query encadenada
      const chainableMock = {
        sort: jest.fn().mockReturnThis(),
        exec: jest.fn().mockResolvedValue(mockLastMessage),
      };

      messageModelMock.findOne.mockReturnValue(chainableMock);

      // Act - Obtener Ãºltimo mensaje
      const lastMessageResult = await messageRepository.getLastMessage(
        ChatId.create(testChatId),
      );

      // Debug information if test fails
      if (lastMessageResult.isErr()) {
        console.log('Error al obtener Ãºltimo mensaje:', lastMessageResult.error.message);
      }

      // Assert - Verificar que es el Ãºltimo
      expect(lastMessageResult.isOk()).toBe(true);
      if (lastMessageResult.isOk()) {
        expect(lastMessageResult.unwrap().toPrimitives().content).toBe('Mensaje mÃ¡s reciente');
      }
      expect(messageModelMock.findOne).toHaveBeenCalledWith({ 
        chatId: testChatId, 
        isDeleted: false 
      });
    });
  });

  describe('GestiÃ³n de Errores Mock', () => {
    it('deberÃ­a manejar bÃºsquedas de entidades inexistentes', async () => {
      // Mock para retornar null
      chatModelMock.findOne.mockResolvedValue(null);
      
      // Mock para mensaje con query encadenada
      const chainableMock = {
        sort: jest.fn().mockReturnThis(),
        exec: jest.fn().mockResolvedValue(null),
      };
      messageModelMock.findOne.mockReturnValue(chainableMock);

      // Chat inexistente
      const chatResult = await chatRepository.findById(ChatId.create(Uuid.random().value));
      expect(chatResult.isErr()).toBe(true);

      // Mensaje inexistente
      const msgResult = await messageRepository.findById(MessageId.create(Uuid.random().value));
      expect(msgResult.isErr()).toBe(true);
    });

    it('deberÃ­a manejar errores de base de datos', async () => {
      // Arrange - Simular error de base de datos
      const dbError = new Error('Database connection failed');
      chatModelMock.create.mockRejectedValue(dbError);

      const chat = Chat.fromPrimitives({
        id: Uuid.random().value,
        status: 'PENDING',
        priority: 'NORMAL',
        visitorId: Uuid.random().value,
        availableCommercialIds: [],
        visitorInfo: { name: 'Test User' },
        metadata: { department: 'test', source: 'web' },
        totalMessages: 0,
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      // Act
      const saveResult = await chatRepository.save(chat);

      // Assert
      expect(saveResult.isErr()).toBe(true);
    });
  });

  describe('Performance BÃ¡sica Mock', () => {
    it('deberÃ­a simular manejo de mÃºltiples chats', async () => {
      // Arrange - Simular guardado de mÃºltiples chats
      const chatCount = 10;
      const mockChats = Array.from({ length: chatCount }, (_, i) => ({
        id: Uuid.random().value,
        status: 'PENDING',
        priority: 'NORMAL',
        visitorId: Uuid.random().value,
        visitorInfo: { name: `Usuario Test ${i}` },
        totalMessages: 0,
      }));

      chatModelMock.create.mockImplementation((data) => Promise.resolve(data));
      chatModelMock.countDocuments.mockResolvedValue(chatCount);
      chatModelMock.findOne.mockImplementation((query) => {
        return Promise.resolve(mockChats.find(chat => chat.id === query.id));
      });

      // Act - Crear mÃºltiples chats
      const chatIds: string[] = [];
      for (let i = 0; i < chatCount; i++) {
        const chatId = ChatId.generate();
        chatIds.push(chatId.value);
        
        const chat = Chat.fromPrimitives({
          id: chatId.value,
          status: 'PENDING',
          priority: 'NORMAL',
          visitorId: Uuid.random().value,
          availableCommercialIds: [],
          visitorInfo: { name: `Usuario Test ${i}` },
          metadata: { department: 'ventas', source: 'website' },
          totalMessages: 0,
          createdAt: new Date(),
          updatedAt: new Date(),
        });

        await chatRepository.save(chat);
      }

      // Assert - Verificar que todos se guardaron
      expect(chatModelMock.create).toHaveBeenCalledTimes(chatCount);

      // Verificar que podemos recuperar cada uno (simulado)
      for (const chatId of chatIds.slice(0, 3)) { // Solo probar los primeros 3 para eficiencia
        const result = await chatRepository.findById(ChatId.create(chatId));
        expect(chatModelMock.findOne).toHaveBeenCalledWith({ id: chatId });
      }
    });
  });
});