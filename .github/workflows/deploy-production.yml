name: Deploy to Production

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Cache Node.js modules
        uses: actions/cache@v3
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install OpenVPN and sshpass
        run: sudo apt-get update && sudo apt-get install -y openvpn sshpass

      - name: Setup OpenVPN config
        run: |
          echo "${{ secrets.OVPN_CONFIG }}" > vpn.conf
        shell: bash

      - name: Connect to VPN
        run: sudo openvpn --config vpn.conf --daemon && sleep 15

      - name: Add server to known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan 10.8.0.1 >> ~/.ssh/known_hosts

      - name: Test SSH connection with password
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} "echo '‚úîÔ∏è SSH OK with password'"
      
      #Instala nestJs CLI en el server
      - name: Install nestJs CLI
        run: |
          npm install -g @nestjs/cli

      # Instala dependencias de producci√≥n y compila el proyecto localmente
      - name: Install prod dependencies and build
        run: |
          npm install --omit=dev
          npm run build

      # Empaqueta dist, package.json, package-lock.json para enviar al server
      - name: Prepare dist for deploy
        run: |
          tar czf deploy-dist.tar.gz dist package.json package-lock.json

      # Genera .env.production localmente y copia todo a /var/www/guiders-backend/ en el server
      - name: Copy dist and .env.production to server
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          echo 'PORT=${{ secrets.PORT }}' > .env.production
          echo 'DATABASE_HOST=${{ secrets.DATABASE_HOST }}' >> .env.production
          echo 'DATABASE_PORT=${{ secrets.DATABASE_PORT }}' >> .env.production
          echo 'DATABASE_USERNAME=${{ secrets.DATABASE_USERNAME }}' >> .env.production
          echo 'DATABASE_PASSWORD=${{ secrets.DATABASE_PASSWORD }}' >> .env.production
          echo 'DATABASE=${{ secrets.DATABASE }}' >> .env.production
          echo 'APP_URL=${{ secrets.APP_URL }}' >> .env.production
          echo 'ENCRYPTION_KEY=${{ secrets.ENCRYPTION_KEY }}' >> .env.production
          echo 'GLOBAL_TOKEN_SECRET=${{ secrets.GLOBAL_TOKEN_SECRET }}' >> .env.production
          echo 'ACCESS_TOKEN_EXPIRATION=${{ secrets.ACCESS_TOKEN_EXPIRATION }}' >> .env.production
          echo 'REFRESH_TOKEN_EXPIRATION=${{ secrets.REFRESH_TOKEN_EXPIRATION }}' >> .env.production
          echo 'REDIS_PORT=${{ secrets.REDIS_PORT }}' >> .env.production
          echo 'REDIS_URL=${{ secrets.REDIS_URL }}' >> .env.production
          echo 'MONGODB_HOST=localhost' >> .env.production
          echo 'MONGODB_DATABASE=${{ secrets.MONGODB_DATABASE }}' >> .env.production
          echo 'MONGODB_PORT=${{ secrets.MONGODB_PORT }}' >> .env.production
          echo 'MONGODB_ROOT_USERNAME=${{ secrets.MONGODB_ROOT_USERNAME }}' >> .env.production
          echo 'MONGODB_ROOT_PASSWORD=${{ secrets.MONGODB_ROOT_PASSWORD }}' >> .env.production
          echo 'NODE_ENV=production' >> .env.production

          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} "mkdir -p /var/www/guiders-backend/"
          sshpass -p "$SSH_PASSWORD" scp -o StrictHostKeyChecking=no deploy-dist.tar.gz .env.production ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }}:/var/www/guiders-backend/

      # Copia docker-compose-prod.yml al servidor
      - name: Copy docker-compose-prod.yml to server
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          sshpass -p "$SSH_PASSWORD" scp -o StrictHostKeyChecking=no docker-compose-prod.yml ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }}:/var/www/guiders-backend/

      # Copia el script de inicializaci√≥n de MongoDB al servidor
      - name: Copy MongoDB initialization script to server
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} "mkdir -p /var/www/guiders-backend/scripts/"
          sshpass -p "$SSH_PASSWORD" scp -o StrictHostKeyChecking=no scripts/mongo-init.js ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }}:/var/www/guiders-backend/scripts/

      # Copia el script de test de MongoDB al servidor
      - name: Copy MongoDB test script to server
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          sshpass -p "$SSH_PASSWORD" scp -o StrictHostKeyChecking=no bin/test-mongodb-connection.js ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }}:/var/www/guiders-backend/

      # Descomprime y prepara entorno en el server
      - name: Unpack dist and install on server
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} "\
            cd /var/www/guiders-backend/ && \
            tar xzf deploy-dist.tar.gz && \
            rm -rf node_modules && \
            npm install --omit=dev \
          "

      # Levanta la base de datos con docker-compose
      - name: Start database with docker-compose
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} "\
            cd /var/www/guiders-backend/ && \
            echo 'üê≥ Iniciando contenedores con docker-compose...' && \
            docker compose --env-file .env.production -f docker-compose-prod.yml up -d --remove-orphans && \
            echo '‚úÖ Comando docker-compose completado' && \
            echo 'üìä Estado inmediato de contenedores:' && \
            docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}' \
          "

      # Verificar que los contenedores se iniciaron correctamente
      - name: Verify containers started
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} "\
            echo 'üîç Verificando que los contenedores se iniciaron correctamente...' && \
            sleep 10 && \
            \
            # Verificar que los contenedores esperados existen \
            containers=('postgres-prod' 'mongodb-prod' 'redis-prod') && \
            for container in \"\${containers[@]}\"; do \
              if docker ps --format '{{.Names}}' | grep -q \"^\$container\$\"; then \
                status=\$(docker ps --format '{{.Names}}\t{{.Status}}' | grep \"^\$container\" | cut -f2) && \
                echo \"  ‚úÖ \$container: \$status\"; \
              else \
                echo \"  ‚ùå \$container: NO ENCONTRADO\"; \
                echo \"üìã Contenedores disponibles:\"; \
                docker ps --format 'table {{.Names}}\t{{.Status}}' && \
                echo \"üìã Logs de docker-compose:\"; \
                docker compose --env-file .env.production -f docker-compose-prod.yml logs --tail 20 && \
                exit 1; \
              fi; \
            done && \
            echo '‚úÖ Todos los contenedores esperados est√°n iniciados' \
          "

      # M√©todo alternativo m√°s r√°pido: usar docker-compose para esperar health checks
      - name: Wait for databases using docker-compose (fast method)
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} "\
            cd /var/www/guiders-backend/ && \
            echo 'üöÄ M√©todo r√°pido: Esperando health checks con docker-compose...' && \
            \
            # Intentar usar docker-compose para esperar a que los servicios est√©n healthy \
            timeout 120 sh -c 'while ! docker-compose --env-file .env.production -f docker-compose-prod.yml ps | grep -E \"postgres-prod.*healthy\" && docker-compose --env-file .env.production -f docker-compose-prod.yml ps | grep -E \"mongodb-prod.*healthy\" && docker-compose --env-file .env.production -f docker-compose-prod.yml ps | grep -E \"redis-prod.*healthy\"; do echo \"‚è≥ Esperando health checks...\"; sleep 5; done' && \
            echo '‚úÖ Health checks completados!' || \
            echo '‚ö†Ô∏è  M√©todo r√°pido fall√≥, continuando con m√©todo detallado...' \
          " || true

      # Esperar a que los servicios est√©n listos antes de ejecutar migraciones
      - name: Wait for databases to be ready
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} "\
            echo 'üîÑ Esperando a que las bases de datos est√©n listas...' && \
            echo 'üìä Verificando estado inicial de contenedores:' && \
            docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}' | grep -E '(postgres-prod|mongodb-prod|redis-prod)' || echo 'No se encontraron contenedores de BD' && \
            echo '' && \
            \
            timeout=180 && \
            interval=10 && \
            attempts=\$((timeout / interval)) && \
            \
            for i in \$(seq 1 \$attempts); do \
              postgres_healthy=false; \
              mongodb_healthy=false; \
              redis_healthy=false; \
              all_healthy=true; \
              \
              echo \"‚è±Ô∏è  Intento \$i/\$attempts (timeout en \$((timeout - (i-1)*interval))s):\"; \
              \
              # Verificar health status de cada contenedor usando Docker health checks \
              for service in postgres-prod mongodb-prod redis-prod; do \
                health_status=\$(docker inspect --format='{{.State.Health.Status}}' \$service 2>/dev/null || echo 'no-healthcheck'); \
                \
                case \$health_status in \
                  'healthy') \
                    echo \"  ‚úÖ \$service: HEALTHY\"; \
                    case \$service in \
                      'postgres-prod') postgres_healthy=true ;; \
                      'mongodb-prod') mongodb_healthy=true ;; \
                      'redis-prod') redis_healthy=true ;; \
                    esac ;; \
                  'starting') \
                    echo \"  üîÑ \$service: STARTING...\"; \
                    all_healthy=false ;; \
                  'unhealthy') \
                    echo \"  ‚ùå \$service: UNHEALTHY\"; \
                    all_healthy=false ;; \
                  'no-healthcheck') \
                    # Fallback a verificaci√≥n manual si no hay health check \
                    if [ \$service = 'postgres-prod' ]; then \
                      if docker exec \$service pg_isready -U \$DATABASE_USERNAME >/dev/null 2>&1; then \
                        echo \"  ‚úÖ \$service: READY (manual check)\"; \
                        postgres_healthy=true; \
                      else \
                        echo \"  ‚ùå \$service: NOT READY (manual check)\"; \
                        all_healthy=false; \
                      fi; \
                    elif [ \$service = 'mongodb-prod' ]; then \
                      if docker exec \$service mongosh --eval 'db.adminCommand(\"ping\")' --quiet >/dev/null 2>&1; then \
                        echo \"  ‚úÖ \$service: READY (manual check)\"; \
                        mongodb_healthy=true; \
                      else \
                        echo \"  ‚ùå \$service: NOT READY (manual check)\"; \
                        all_healthy=false; \
                      fi; \
                    elif [ \$service = 'redis-prod' ]; then \
                      if docker exec \$service redis-cli ping >/dev/null 2>&1; then \
                        echo \"  ‚úÖ \$service: READY (manual check)\"; \
                        redis_healthy=true; \
                      else \
                        echo \"  ‚ùå \$service: NOT READY (manual check)\"; \
                        all_healthy=false; \
                      fi; \
                    fi ;; \
                  *) \
                    echo \"  ‚ö†Ô∏è  \$service: UNKNOWN STATUS (\$health_status)\"; \
                    all_healthy=false ;; \
                esac; \
              done; \
              \
              # Si todos est√°n healthy, salir del loop \
              if \$postgres_healthy && \$mongodb_healthy && \$redis_healthy; then \
                echo ''; \
                echo '‚úÖ ¬°Todas las bases de datos est√°n healthy y listas!'; \
                break; \
              fi; \
              \
              # Si es el √∫ltimo intento, mostrar error detallado y fallar \
              if [ \$i -eq \$attempts ]; then \
                echo ''; \
                echo '‚ùå TIMEOUT: Las bases de datos no estuvieron listas en \${timeout}s'; \
                echo 'üìä Estado final de contenedores:'; \
                docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}' | grep -E '(postgres-prod|mongodb-prod|redis-prod)' || true; \
                echo ''; \
                echo 'üè• Health status detallado:'; \
                for service in postgres-prod mongodb-prod redis-prod; do \
                  health=\$(docker inspect --format='{{.State.Health.Status}}' \$service 2>/dev/null || echo 'no-healthcheck'); \
                  echo \"  \$service: \$health\"; \
                done; \
                echo ''; \
                echo 'üìã √öltimos logs de contenedores:'; \
                for service in postgres-prod mongodb-prod redis-prod; do \
                  echo \"--- \$service logs (√∫ltimas 5 l√≠neas) ---\"; \
                  docker logs \$service --tail 5 2>/dev/null || echo \"No se pudieron obtener logs de \$service\"; \
                  echo ''; \
                done; \
                exit 1; \
              fi; \
              \
              echo \"  ‚è≥ Esperando \${interval}s antes del siguiente intento...\"; \
              sleep \$interval; \
            done \
          "

      # Test MongoDB connection usando el script de test en modo producci√≥n
      - name: Test MongoDB connection
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} "\
            cd /var/www/guiders-backend/ && \
            echo 'üîç Probando conexi√≥n a MongoDB en modo producci√≥n...' && \
            NODE_ENV=production node test-mongodb-connection.js \
          "

      # Ejecuta migraciones de TypeORM en el servidor antes de reiniciar la app
      - name: Run TypeORM migrations on server
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} "\
            cd /var/www/guiders-backend/ && \
            NODE_ENV=production npx typeorm migration:run -d dist/src/data-source.js \
          "

      # Reinicia la app con pm2 del sistema
      - name: Restart app with pm2
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} "\
            cd /var/www/guiders-backend/ && \
            pm2 delete guiders-backend || true && \
            NODE_ENV=production pm2 start dist/src/main.js --name guiders-backend \
          "
          
      # dar permisos de ejecuci√≥n a /dist/tools/cli.js
      - name: Set execute permissions for cli.js
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} "\
            chmod +x /var/www/guiders-backend/dist/tools/cli.js \
          "

      # Verificar que todos los servicios est√©n funcionando
      - name: Verify deployment status
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} "\
            cd /var/www/guiders-backend/ && \
            echo 'üîç Verificando estado del despliegue...' && \
            echo 'üìã Configuraci√≥n .env.production:' && \
            cat .env.production && \
            echo '' && \
            echo 'üìä Estado de PM2:' && \
            pm2 list | grep guiders-backend || echo 'App no encontrada en PM2' && \
            echo 'üìä Estado de Docker:' && \
            docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}' | grep -E '(postgres-prod|redis-prod|mongodb-prod)' && \
            echo '‚úÖ Verificaci√≥n de despliegue completada' \
          "

      # Instalar Artillery en el servidor para load testing
      - name: Install Artillery for load testing
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} "\
            echo 'üîß Instalando Artillery para load testing...' && \
            npm install -g artillery && \
            echo '‚úÖ Artillery instalado correctamente' \
          "

      # Crear directorio para load testing y copiar archivos
      - name: Setup load testing tools on server
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          # Crear directorio para load testing
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} "mkdir -p /var/www/guiders-backend/load-tests/"
          
          # Copiar archivos de load testing
          sshpass -p "$SSH_PASSWORD" scp -o StrictHostKeyChecking=no test/load/custom-functions.js ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }}:/var/www/guiders-backend/load-tests/
          sshpass -p "$SSH_PASSWORD" scp -o StrictHostKeyChecking=no test/load/production-load-test.yml ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }}:/var/www/guiders-backend/load-tests/
          sshpass -p "$SSH_PASSWORD" scp -o StrictHostKeyChecking=no test/load/production-stress-test.yml ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }}:/var/www/guiders-backend/load-tests/
          sshpass -p "$SSH_PASSWORD" scp -o StrictHostKeyChecking=no test/load/simple-test.yml ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }}:/var/www/guiders-backend/load-tests/
          sshpass -p "$SSH_PASSWORD" scp -o StrictHostKeyChecking=no test/load/run-production-load-tests.sh ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }}:/var/www/guiders-backend/load-tests/
          sshpass -p "$SSH_PASSWORD" scp -o StrictHostKeyChecking=no test/load/PRODUCTION-README.md ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }}:/var/www/guiders-backend/load-tests/
          sshpass -p "$SSH_PASSWORD" scp -o StrictHostKeyChecking=no test/load/quick-guide.sh ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }}:/var/www/guiders-backend/load-tests/
          
          # Dar permisos de ejecuci√≥n al script
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} "\
            chmod +x /var/www/guiders-backend/load-tests/run-production-load-tests.sh && \
            chmod +x /var/www/guiders-backend/load-tests/quick-guide.sh && \
            echo '‚úÖ Herramientas de load testing configuradas en /var/www/guiders-backend/load-tests/' \
          "

      # Verificar instalaci√≥n de load testing
      - name: Verify load testing installation
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} "\
            cd /var/www/guiders-backend/load-tests/ && \
            echo 'üîç Verificando instalaci√≥n de load testing...' && \
            echo 'üìÅ Archivos disponibles:' && \
            ls -la && \
            echo '' && \
            echo 'üîß Versi√≥n de Artillery:' && \
            artillery --version && \
            echo '' && \
            echo 'üí° Para usar las pruebas de carga:' && \
            echo '   cd /var/www/guiders-backend/load-tests/' && \
            echo '   ./run-production-load-tests.sh simple' && \
            echo '   ./run-production-load-tests.sh normal' && \
            echo '   ./run-production-load-tests.sh stress' && \
            echo '‚úÖ Load testing tools ready!' \
          "