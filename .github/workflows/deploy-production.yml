name: Deploy to Production

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Cache Node.js modules
        uses: actions/cache@v3
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install OpenVPN and sshpass
        run: sudo apt-get update && sudo apt-get install -y openvpn sshpass

      - name: Setup OpenVPN config
        run: |
          echo "${{ secrets.OVPN_CONFIG }}" > vpn.conf
        shell: bash

      - name: Connect to VPN
        run: sudo openvpn --config vpn.conf --daemon && sleep 15

      - name: Add server to known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan 10.8.0.1 >> ~/.ssh/known_hosts

      - name: Test SSH connection with password
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} "echo '‚úîÔ∏è SSH OK with password'"
      
      #Instala nestJs CLI en el server
      - name: Install nestJs CLI
        run: |
          npm install -g @nestjs/cli

      # Instala dependencias de producci√≥n y compila el proyecto localmente
      - name: Install prod dependencies and build
        run: |
          npm install --omit=dev
          npm run build

      # Empaqueta dist, package.json, package-lock.json para enviar al server
      - name: Prepare dist for deploy
        run: |
          tar czf deploy-dist.tar.gz dist package.json package-lock.json

      # Genera .env.production localmente y copia todo a /var/www/guiders-backend/ en el server
      - name: Copy dist and .env.production to server
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          echo 'PORT=${{ secrets.PORT }}' > .env.production
          echo 'DATABASE_HOST=${{ secrets.DATABASE_HOST }}' >> .env.production
          echo 'DATABASE_PORT=${{ secrets.DATABASE_PORT }}' >> .env.production
          echo 'DATABASE_USERNAME=${{ secrets.DATABASE_USERNAME }}' >> .env.production
          echo 'DATABASE_PASSWORD=${{ secrets.DATABASE_PASSWORD }}' >> .env.production
          echo 'DATABASE=${{ secrets.DATABASE }}' >> .env.production
          echo 'APP_URL=${{ secrets.APP_URL }}' >> .env.production
          echo 'ENCRYPTION_KEY=${{ secrets.ENCRYPTION_KEY }}' >> .env.production
          echo 'GLOBAL_TOKEN_SECRET=${{ secrets.GLOBAL_TOKEN_SECRET }}' >> .env.production
          echo 'ACCESS_TOKEN_EXPIRATION=${{ secrets.ACCESS_TOKEN_EXPIRATION }}' >> .env.production
          echo 'REFRESH_TOKEN_EXPIRATION=${{ secrets.REFRESH_TOKEN_EXPIRATION }}' >> .env.production
          echo 'REDIS_PORT=${{ secrets.REDIS_PORT }}' >> .env.production
          echo 'REDIS_URL=${{ secrets.REDIS_URL }}' >> .env.production
          echo 'MONGODB_HOST=localhost' >> .env.production
          echo 'MONGODB_DATABASE=${{ secrets.MONGODB_DATABASE }}' >> .env.production
          echo 'MONGODB_PORT=${{ secrets.MONGODB_PORT }}' >> .env.production
          echo 'MONGODB_ROOT_USERNAME=${{ secrets.MONGODB_ROOT_USERNAME }}' >> .env.production
          echo 'MONGODB_ROOT_PASSWORD=${{ secrets.MONGODB_ROOT_PASSWORD }}' >> .env.production
          echo 'NODE_ENV=production' >> .env.production

          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} "mkdir -p /var/www/guiders-backend/"
          sshpass -p "$SSH_PASSWORD" scp -o StrictHostKeyChecking=no deploy-dist.tar.gz .env.production ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }}:/var/www/guiders-backend/

      # Copia docker-compose-prod.yml al servidor
      - name: Copy docker-compose-prod.yml to server
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          sshpass -p "$SSH_PASSWORD" scp -o StrictHostKeyChecking=no docker-compose-prod.yml ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }}:/var/www/guiders-backend/

      # Copia el script de inicializaci√≥n de MongoDB al servidor
      - name: Copy MongoDB initialization script to server
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} "mkdir -p /var/www/guiders-backend/scripts/"
          sshpass -p "$SSH_PASSWORD" scp -o StrictHostKeyChecking=no scripts/mongo-init.js ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }}:/var/www/guiders-backend/scripts/

      # Copia el script de test de MongoDB al servidor
      - name: Copy MongoDB test script to server
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          sshpass -p "$SSH_PASSWORD" scp -o StrictHostKeyChecking=no bin/test-mongodb-connection.js ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }}:/var/www/guiders-backend/

      # Descomprime y prepara entorno en el server
      - name: Unpack dist and install on server
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} "\
            cd /var/www/guiders-backend/ && \
            tar xzf deploy-dist.tar.gz && \
            rm -rf node_modules && \
            npm install --omit=dev \
          "

      # Levanta la base de datos con docker-compose
      - name: Start database with docker-compose
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} "\
            cd /var/www/guiders-backend/ && \
            echo 'üê≥ Iniciando contenedores con docker-compose...' && \
            docker compose --env-file .env.production -f docker-compose-prod.yml up -d --remove-orphans && \
            echo '‚úÖ Comando docker-compose completado' && \
            echo 'üìä Estado inmediato de contenedores:' && \
            docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}' \
          "

      # Verificar que los contenedores se iniciaron correctamente
      - name: Verify containers started
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} "\
            echo 'üîç Verificando que los contenedores se iniciaron correctamente...' && \
            sleep 10 && \
            \
            # Verificar que los contenedores esperados existen \
            containers=('postgres-prod' 'mongodb-prod' 'redis-prod') && \
            for container in \"\${containers[@]}\"; do \
              if docker ps --format '{{.Names}}' | grep -q \"^\$container\$\"; then \
                status=\$(docker ps --format '{{.Names}}\t{{.Status}}' | grep \"^\$container\" | cut -f2) && \
                echo \"  ‚úÖ \$container: \$status\"; \
              else \
                echo \"  ‚ùå \$container: NO ENCONTRADO\"; \
                echo \"üìã Contenedores disponibles:\"; \
                docker ps --format 'table {{.Names}}\t{{.Status}}' && \
                echo \"üìã Logs de docker-compose:\"; \
                docker compose --env-file .env.production -f docker-compose-prod.yml logs --tail 20 && \
                exit 1; \
              fi; \
            done && \
            echo '‚úÖ Todos los contenedores esperados est√°n iniciados' \
          "

      # M√©todo alternativo m√°s r√°pido: usar docker-compose para esperar health checks
      - name: Wait for databases using docker-compose (fast method)
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} "\
            cd /var/www/guiders-backend/ && \
            echo 'üöÄ M√©todo r√°pido: Esperando health checks con docker-compose...' && \
            \
            # Esperar 30 segundos y luego verificar health status \
            echo '‚è≥ Esperando 30s para que los contenedores se inicialicen...' && \
            sleep 30 && \
            \
            # Verificar health status con timeout \
            for i in {1..12}; do \
              postgres_health=\$(docker inspect --format='{{.State.Health.Status}}' postgres-prod 2>/dev/null || echo 'starting'); \
              mongodb_health=\$(docker inspect --format='{{.State.Health.Status}}' mongodb-prod 2>/dev/null || echo 'starting'); \
              redis_health=\$(docker inspect --format='{{.State.Health.Status}}' redis-prod 2>/dev/null || echo 'starting'); \
              \
              echo \"Intento \$i/12: PostgreSQL=\$postgres_health, MongoDB=\$mongodb_health, Redis=\$redis_health\"; \
              \
              if [ \"\$postgres_health\" = 'healthy' ] && [ \"\$mongodb_health\" = 'healthy' ] && [ \"\$redis_health\" = 'healthy' ]; then \
                echo '‚úÖ Todos los servicios est√°n healthy!'; \
                exit 0; \
              fi; \
              \
              sleep 10; \
            done; \
            \
            echo '‚ö†Ô∏è  M√©todo r√°pido no complet√≥ en 2 minutos, continuando con m√©todo detallado...' \
          " || true

      # Esperar a que los servicios est√©n listos antes de ejecutar migraciones
      - name: Wait for databases to be ready (detailed method)
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} "\
            echo 'üîÑ M√©todo detallado: Verificando estado de bases de datos...' && \
            echo 'üìä Estado inicial de contenedores:' && \
            docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}' | grep -E '(postgres-prod|mongodb-prod|redis-prod)' || echo 'No se encontraron contenedores de BD' && \
            echo '' && \
            \
            # Configuraci√≥n de timeout \
            max_attempts=18 && \
            interval=10 && \
            \
            for i in \$(seq 1 \$max_attempts); do \
              postgres_ready=false && \
              mongodb_ready=false && \
              redis_ready=false && \
              \
              echo \"‚è±Ô∏è  Intento \$i/\$max_attempts:\"; \
              \
              # Verificar PostgreSQL \
              if docker exec postgres-prod pg_isready -U \$DATABASE_USERNAME >/dev/null 2>&1; then \
                postgres_ready=true && \
                echo '  ‚úÖ PostgreSQL: READY'; \
              else \
                echo '  ‚ùå PostgreSQL: NOT READY'; \
              fi; \
              \
              # Verificar MongoDB \
              if docker exec mongodb-prod mongosh --eval 'db.adminCommand(\"ping\")' --quiet >/dev/null 2>&1; then \
                mongodb_ready=true && \
                echo '  ‚úÖ MongoDB: READY'; \
              else \
                echo '  ‚ùå MongoDB: NOT READY'; \
              fi; \
              \
              # Verificar Redis \
              if docker exec redis-prod redis-cli ping >/dev/null 2>&1; then \
                redis_ready=true && \
                echo '  ‚úÖ Redis: READY'; \
              else \
                echo '  ‚ùå Redis: NOT READY'; \
              fi; \
              \
              # Si todos est√°n listos, salir \
              if [ \"\$postgres_ready\" = true ] && [ \"\$mongodb_ready\" = true ] && [ \"\$redis_ready\" = true ]; then \
                echo ''; \
                echo '‚úÖ ¬°Todas las bases de datos est√°n listas!'; \
                break; \
              fi; \
              \
              # Si es el √∫ltimo intento, fallar \
              if [ \$i -eq \$max_attempts ]; then \
                echo ''; \
                echo '‚ùå TIMEOUT: Las bases de datos no estuvieron listas en 3 minutos'; \
                echo 'üìä Estado final:'; \
                docker ps --format 'table {{.Names}}\t{{.Status}}' | grep -E '(postgres-prod|mongodb-prod|redis-prod)' || true; \
                echo ''; \
                echo 'üìã Logs recientes:'; \
                echo '--- PostgreSQL ---'; \
                docker logs postgres-prod --tail 5 2>/dev/null || echo 'No logs disponibles'; \
                echo '--- MongoDB ---'; \
                docker logs mongodb-prod --tail 5 2>/dev/null || echo 'No logs disponibles'; \
                echo '--- Redis ---'; \
                docker logs redis-prod --tail 5 2>/dev/null || echo 'No logs disponibles'; \
                exit 1; \
              fi; \
              \
              echo \"  ‚è≥ Esperando \${interval}s...\"; \
              sleep \$interval; \
            done \
          "

      # Test MongoDB connection usando el script de test en modo producci√≥n
      - name: Test MongoDB connection
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} "\
            cd /var/www/guiders-backend/ && \
            echo 'üîç Probando conexi√≥n a MongoDB en modo producci√≥n...' && \
            NODE_ENV=production node test-mongodb-connection.js \
          "

      # Ejecuta migraciones de TypeORM en el servidor antes de reiniciar la app
      - name: Run TypeORM migrations on server
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} "\
            cd /var/www/guiders-backend/ && \
            NODE_ENV=production npx typeorm migration:run -d dist/src/data-source.js \
          "

      # Reinicia la app con pm2 del sistema
      - name: Restart app with pm2
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} "\
            cd /var/www/guiders-backend/ && \
            pm2 delete guiders-backend || true && \
            NODE_ENV=production pm2 start dist/src/main.js --name guiders-backend \
          "
          
      # dar permisos de ejecuci√≥n a /dist/tools/cli.js
      - name: Set execute permissions for cli.js
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} "\
            chmod +x /var/www/guiders-backend/dist/tools/cli.js \
          "

      # Verificar que todos los servicios est√©n funcionando
      - name: Verify deployment status
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} "\
            cd /var/www/guiders-backend/ && \
            echo 'üîç Verificando estado del despliegue...' && \
            echo 'üìã Configuraci√≥n .env.production:' && \
            cat .env.production && \
            echo '' && \
            echo 'üìä Estado de PM2:' && \
            pm2 list | grep guiders-backend || echo 'App no encontrada en PM2' && \
            echo 'üìä Estado de Docker:' && \
            docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}' | grep -E '(postgres-prod|redis-prod|mongodb-prod)' && \
            echo '‚úÖ Verificaci√≥n de despliegue completada' \
          "

      # Instalar Artillery en el servidor para load testing
      - name: Install Artillery for load testing
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} "\
            echo 'üîß Instalando Artillery para load testing...' && \
            npm install -g artillery && \
            echo '‚úÖ Artillery instalado correctamente' \
          "

      # Crear directorio para load testing y copiar archivos
      - name: Setup load testing tools on server
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          # Crear directorio para load testing
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} "mkdir -p /var/www/guiders-backend/load-tests/"
          
          # Copiar archivos de load testing
          sshpass -p "$SSH_PASSWORD" scp -o StrictHostKeyChecking=no test/load/custom-functions.js ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }}:/var/www/guiders-backend/load-tests/
          sshpass -p "$SSH_PASSWORD" scp -o StrictHostKeyChecking=no test/load/production-load-test.yml ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }}:/var/www/guiders-backend/load-tests/
          sshpass -p "$SSH_PASSWORD" scp -o StrictHostKeyChecking=no test/load/production-stress-test.yml ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }}:/var/www/guiders-backend/load-tests/
          sshpass -p "$SSH_PASSWORD" scp -o StrictHostKeyChecking=no test/load/simple-test.yml ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }}:/var/www/guiders-backend/load-tests/
          sshpass -p "$SSH_PASSWORD" scp -o StrictHostKeyChecking=no test/load/run-production-load-tests.sh ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }}:/var/www/guiders-backend/load-tests/
          sshpass -p "$SSH_PASSWORD" scp -o StrictHostKeyChecking=no test/load/PRODUCTION-README.md ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }}:/var/www/guiders-backend/load-tests/
          sshpass -p "$SSH_PASSWORD" scp -o StrictHostKeyChecking=no test/load/quick-guide.sh ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }}:/var/www/guiders-backend/load-tests/
          
          # Dar permisos de ejecuci√≥n al script
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} "\
            chmod +x /var/www/guiders-backend/load-tests/run-production-load-tests.sh && \
            chmod +x /var/www/guiders-backend/load-tests/quick-guide.sh && \
            echo '‚úÖ Herramientas de load testing configuradas en /var/www/guiders-backend/load-tests/' \
          "

      # Verificar instalaci√≥n de load testing
      - name: Verify load testing installation
        env:
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} "\
            cd /var/www/guiders-backend/load-tests/ && \
            echo 'üîç Verificando instalaci√≥n de load testing...' && \
            echo 'üìÅ Archivos disponibles:' && \
            ls -la && \
            echo '' && \
            echo 'üîß Versi√≥n de Artillery:' && \
            artillery --version && \
            echo '' && \
            echo 'üí° Para usar las pruebas de carga:' && \
            echo '   cd /var/www/guiders-backend/load-tests/' && \
            echo '   ./run-production-load-tests.sh simple' && \
            echo '   ./run-production-load-tests.sh normal' && \
            echo '   ./run-production-load-tests.sh stress' && \
            echo '‚úÖ Load testing tools ready!' \
          "