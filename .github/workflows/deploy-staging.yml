name: Deploy to Staging

on:
  push:
    branches: [ develop, feature/*]
  workflow_dispatch:

env:
  NODE_VERSION: '20'

jobs:
  # Test b√°sico y build
  test-and-build:
    name: Test and Build
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    services:
      # PostgreSQL para tests de integraci√≥n
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install system dependencies for MongoDB Memory Server
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libssl-dev \
            libssl1.1 \
            openssl \
            ca-certificates \
            curl \
            gnupg \
            lsb-release
          
          # Verificar que las bibliotecas est√©n disponibles
          echo "üîç Verificando bibliotecas OpenSSL disponibles:"
          find /usr/lib /lib -name "libcrypto.so*" -o -name "libssl.so*" 2>/dev/null | head -10 || true
          
          # Crear enlaces simb√≥licos si es necesario
          if [ ! -f /usr/lib/x86_64-linux-gnu/libcrypto.so.1.1 ] && [ -f /usr/lib/x86_64-linux-gnu/libcrypto.so.3 ]; then
            sudo ln -sf /usr/lib/x86_64-linux-gnu/libcrypto.so.3 /usr/lib/x86_64-linux-gnu/libcrypto.so.1.1
            echo "‚úÖ Creado enlace simb√≥lico para libcrypto.so.1.1"
          fi
          
          if [ ! -f /usr/lib/x86_64-linux-gnu/libssl.so.1.1 ] && [ -f /usr/lib/x86_64-linux-gnu/libssl.so.3 ]; then
            sudo ln -sf /usr/lib/x86_64-linux-gnu/libssl.so.3 /usr/lib/x86_64-linux-gnu/libssl.so.1.1
            echo "‚úÖ Creado enlace simb√≥lico para libssl.so.1.1"
          fi
          
          # Instalar MongoDB Community Edition como respaldo
          echo "üì¶ Instalando MongoDB Community Edition como respaldo..."
          curl -fsSL https://pgp.mongodb.com/server-6.0.asc | sudo gpg -o /usr/share/keyrings/mongodb-server-6.0.gpg --dearmor
          echo "deb [ arch=amd64,arm64 signed-by=/usr/share/keyrings/mongodb-server-6.0.gpg ] https://repo.mongodb.org/apt/ubuntu jammy/mongodb-org/6.0 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-6.0.list
          sudo apt-get update
          sudo apt-get install -y mongodb-org-server mongodb-org-tools
          
          # Verificar instalaci√≥n
          echo "‚úÖ MongoDB instalado:"
          mongod --version | head -2 || echo "‚ùå MongoDB no disponible"
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run lint
        run: npm run lint
      
      - name: Build project
        run: npm run build
      
      - name: Run unit tests
        run: npm run test:unit
        
      - name: Verify MongoDB Memory Server
        run: node scripts/check-mongodb-memory-server.js
        env:
          NODE_ENV: test
          CI: true
        
      - name: Run integration tests
        run: npm run test:int
        env:
          # Variables para tests de integraci√≥n
          NODE_ENV: test
          DATABASE_HOST: localhost
          DATABASE_PORT: 5432
          DATABASE_USERNAME: postgres
          DATABASE_PASSWORD: postgres
          DATABASE: test
          # MongoDB Memory Server configuraci√≥n
          MONGOMS_VERSION: '6.0.1'
          MONGOMS_DISABLE_POSTINSTALL: '1'
          MONGOMS_SYSTEM_BINARY: 'mongod'
          # Configuraci√≥n de timeout extendido para CI
          JEST_TIMEOUT: 120000

  # Deploy real a staging (estructura similar a producci√≥n)
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [test-and-build]
    if: needs.test-and-build.result == 'success'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install sshpass
        run: sudo apt-get update && sudo apt-get install -y sshpass

      - name: Install WireGuard
        run: sudo apt-get update && sudo apt-get install -y wireguard

      - name: Configure WireGuard (github.conf)
        run: |
          set -euo pipefail
          sudo mkdir -p /etc/wireguard && sudo chmod 700 /etc/wireguard
          cat > github.conf <<'CFG'
          [Interface]
          PrivateKey = REPLACE_PRIVATE_KEY
          Address = 10.0.0.4/24

          [Peer]
          PublicKey = rcfGmqdqyiQs+J81rx5mabiyAjQkvoDfiCTD2eLqaHQ=
          Endpoint = 217.154.105.26:51820
          AllowedIPs = 10.0.0.0/24
          PersistentKeepalive = 25
          CFG
          sed -i "s#REPLACE_PRIVATE_KEY#${{ secrets.WG_PRIVATE_KEY }}#" github.conf
          sudo mv github.conf /etc/wireguard/github.conf
          sudo chmod 600 /etc/wireguard/github.conf
          # Reiniciar interfaz si existiese
          if sudo wg show github >/dev/null 2>&1; then sudo wg-quick down github || true; fi
          sudo wg-quick up github || { echo "‚ùå Error al levantar WireGuard"; sudo wg-quick down github || true; exit 1; }

      - name: Verify VPN connection
        run: |
          echo "üîç Verificando conexi√≥n VPN..."
          
          # Mostrar informaci√≥n de la interfaz WireGuard
          echo "üìã Estado de WireGuard:"
          sudo wg show
          
          # Verificar todas las interfaces WireGuard
          echo ""
          echo "üìã Interfaces WireGuard activas:"
          ip link show type wireguard 2>/dev/null || echo "No se encontraron interfaces WireGuard"
          
          # Mostrar todas las IPs asignadas a interfaces WireGuard
          echo ""
          echo "üìã IPs asignadas a interfaces WireGuard:"
          for iface in $(ip link show type wireguard 2>/dev/null | grep -o 'wg[^:]*' || echo ""); do
            if [[ -n "$iface" ]]; then
              echo "  $iface:"
              ip addr show "$iface" | grep -E "inet " | sed 's/^/    /'
            fi
          done
          
          # Verificar tabla de rutas
          echo ""
          echo "üìã Rutas VPN:"
          ip route | grep -E "10\.0\.0\.|wg" || echo "No se encontraron rutas VPN"
          
          # Ping al servidor VPN (deber√≠a ser 10.0.0.1 t√≠picamente)
          echo ""
          echo "üèì Probando conectividad VPN:"
          
          # Primero verificar si el endpoint externo es alcanzable
          echo "üîç Verificando alcance del endpoint externo..."
          if ping -c 2 -W 3 ${{ secrets.WG_SERVER_ENDPOINT }}; then
            echo "‚úÖ Endpoint externo alcanzable"
          else
            echo "‚ùå Endpoint externo no alcanzable - problema de red/firewall"
          fi
          
          # Verificar conectividad UDP al puerto WireGuard
          echo ""
          echo "üîç Probando conectividad UDP al puerto 51820..."
          timeout 5 bash -c "</dev/tcp/${{ secrets.WG_SERVER_ENDPOINT }}/51820" 2>/dev/null && echo "‚úÖ Puerto TCP 51820 abierto" || echo "‚ö†Ô∏è Puerto TCP 51820 no responde (normal para UDP)"
          
          # Intentar diferentes IPs del servidor VPN
          echo ""
          echo "üîç Probando diferentes IPs del servidor VPN..."
          for server_ip in "10.0.0.1" "10.0.0.254"; do
            echo "  Probando $server_ip..."
            if timeout 3 ping -c 1 -W 2 "$server_ip" >/dev/null 2>&1; then
              echo "    ‚úÖ $server_ip responde!"
              VPN_SERVER_IP="$server_ip"
              break
            else
              echo "    ‚ùå $server_ip no responde"
            fi
          done
          
          # Si encontramos un servidor que responde, continuar; si no, fallar
          if [[ -n "${VPN_SERVER_IP:-}" ]]; then
            echo "‚úÖ Conexi√≥n VPN exitosa con servidor $VPN_SERVER_IP!"
          else
            echo ""
            echo "‚ùå No se puede establecer conectividad VPN"
            echo "üîç Informaci√≥n de debug:"
            echo "  - Interfaz WireGuard: CONFIGURADA ‚úÖ"
            echo "  - IP del cliente: 10.0.0.3/24 ‚úÖ"
            echo "  - Rutas: CONFIGURADAS ‚úÖ"
            echo "  - Problema: Servidor VPN no responde ‚ùå"
            echo ""
            echo "ÔøΩ Posibles causas:"
            echo "  1. Servidor WireGuard no est√° ejecut√°ndose"
            echo "  2. Firewall bloquea puerto UDP 51820"
            echo "  3. Configuraci√≥n incorrecta en el servidor"
            echo "  4. IP del servidor VPN no es 10.0.0.1"
            echo ""
            echo "üõ†Ô∏è Para debuggear en el servidor:"
            echo "  - Verificar servicio: sudo systemctl status wg-quick@wg0"
            echo "  - Verificar interfaz: sudo wg show"
            echo "  - Verificar firewall: sudo ufw status"
            echo "  - Verificar logs: sudo journalctl -u wg-quick@wg0"
            
            echo ""
            echo "üö´ DETENIENDO DEPLOYMENT - VPN requerida para acceso seguro"
            exit 1
          fi
          
          # Verificar que podemos alcanzar el servidor de staging a trav√©s de la VPN
          echo ""
          echo "üéØ Probando acceso al servidor de staging:"
          if ping -c 2 -W 5 ${{ secrets.STAGING_HOST }}; then
            echo "‚úÖ Servidor de staging accesible a trav√©s de VPN!"
          else
            echo "‚ùå No se puede alcanzar el servidor de staging a trav√©s de VPN"
            echo "üîç Esto puede indicar:"
            echo "  - El servidor staging no est√° en la red VPN"
            echo "  - Firewall en el servidor staging bloquea ICMP"
            echo "  - STAGING_HOST no es la IP correcta dentro de la VPN"
            echo ""
            echo "üö´ DETENIENDO DEPLOYMENT - Servidor de staging no accesible"
            exit 1
          fi

      - name: Add staging server to known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan ${{ secrets.STAGING_HOST }} >> ~/.ssh/known_hosts

      - name: Build and prepare deployment
        run: |
          # Instalar solo dependencias necesarias para el build
          npm ci --include=dev
          npm run build
          
          # Crear package.json optimizado para staging (sin sqlite3)
          node -e "
            const pkg = JSON.parse(require('fs').readFileSync('package.json'));
            // Remover sqlite3 de las dependencias ya que solo se usa en tests
            if (pkg.dependencies && pkg.dependencies.sqlite3) {
              delete pkg.dependencies.sqlite3;
            }
            require('fs').writeFileSync('package-staging.json', JSON.stringify(pkg, null, 2));
          "
          
          tar czf deploy-staging.tar.gz dist package-staging.json package-lock.json

      - name: Create staging environment config
        run: |
          echo "üîß Creando configuraci√≥n para staging..."
          cat > .env.staging << EOF
          PORT=${{ secrets.STAGING_PORT }}
          DATABASE_HOST=${{ secrets.STAGING_DATABASE_HOST }}
          DATABASE_PORT=${{ secrets.STAGING_DATABASE_PORT }}
          DATABASE_USERNAME=${{ secrets.STAGING_DATABASE_USERNAME }}
          DATABASE_PASSWORD=${{ secrets.STAGING_DATABASE_PASSWORD }}
          DATABASE=${{ secrets.STAGING_DATABASE }}
          APP_URL=${{ secrets.STAGING_APP_URL }}
          # JWKS_BASE_URL opcional: si no est√° definido en secrets se usar√° STAGING_APP_URL
          JWKS_BASE_URL_PLACEHOLDER="${{ secrets.STAGING_APP_URL }}"
          # GitHub Actions no permite fallback inline con secretos potencialmente no existentes sin marcar warning.
          # Por simplicidad, siempre usamos STAGING_APP_URL; si se define un secreto separado se podr√° ajustar este bloque.
          JWKS_BASE_URL=$JWKS_BASE_URL_PLACEHOLDER
          echo "Usando JWKS_BASE_URL=$JWKS_BASE_URL"
          ENCRYPTION_KEY=${{ secrets.STAGING_ENCRYPTION_KEY }}
          GLOBAL_TOKEN_SECRET=${{ secrets.STAGING_GLOBAL_TOKEN_SECRET }}
          ACCESS_TOKEN_EXPIRATION=${{ secrets.STAGING_ACCESS_TOKEN_EXPIRATION }}
          REFRESH_TOKEN_EXPIRATION=${{ secrets.STAGING_REFRESH_TOKEN_EXPIRATION }}
          REDIS_PORT=${{ secrets.STAGING_REDIS_PORT }}
          REDIS_URL=${{ secrets.STAGING_REDIS_URL }}
          MONGODB_HOST=localhost
          MONGODB_DATABASE=${{ secrets.STAGING_MONGODB_DATABASE }}
          MONGODB_PORT=${{ secrets.STAGING_MONGODB_PORT }}
          MONGODB_ROOT_USERNAME=${{ secrets.STAGING_MONGODB_ROOT_USERNAME }}
          MONGODB_ROOT_PASSWORD=${{ secrets.STAGING_MONGODB_ROOT_PASSWORD }}
          MONGODB_USERNAME=${{ secrets.STAGING_MONGODB_USERNAME || 'staging_user' }}
          MONGODB_PASSWORD=${{ secrets.STAGING_MONGODB_PASSWORD || 'staging_pass' }}
          REDIS_COMMANDER_PASSWORD=${{ secrets.STAGING_REDIS_COMMANDER_PASSWORD || 'staging123' }}
          MONGO_EXPRESS_PASSWORD=${{ secrets.STAGING_MONGO_EXPRESS_PASSWORD || 'staging123' }}
          NODE_ENV=staging
          LOG_LEVEL=debug
          ENABLE_SWAGGER=true
          # Configuraci√≥n de Keycloak para staging
          KEYCLOAK_ISSUER=${{ secrets.STAGING_KEYCLOAK_ISSUER }}
          KEYCLOAK_JWKS_URI=${{ secrets.STAGING_KEYCLOAK_JWKS_URI }}
          KEYCLOAK_AUDIENCE=account
          # Configuraci√≥n BFF
          OIDC_ISSUER=${{ secrets.STAGING_KEYCLOAK_ISSUER }}
          OIDC_CONSOLE_CLIENT_ID=console
          OIDC_CONSOLE_REDIRECT_URI=${{ secrets.STAGING_APP_URL }}/api/bff/auth/callback/console
          OIDC_ADMIN_CLIENT_ID=admin
          OIDC_ADMIN_REDIRECT_URI=${{ secrets.STAGING_APP_URL }}/api/bff/auth/callback/admin
          # Configuraci√≥n de cookies BFF para staging (HTTPS en producci√≥n)
          SAMESITE=lax
          COOKIE_SECURE=true
          COOKIE_PATH=/
          REFRESH_PATH=/api/bff/auth/refresh
          # Configuraci√≥n de cookies por aplicaci√≥n
          SESSION_COOKIE_CONSOLE=console_session
          REFRESH_COOKIE_CONSOLE=console_refresh
          SESSION_COOKIE_ADMIN=admin_session
          REFRESH_COOKIE_ADMIN=admin_refresh
          # Permitir m√∫ltiples or√≠genes para apps (console + admin)
          ALLOW_RETURN_TO=${{ secrets.STAGING_CONSOLE_URL }},${{ secrets.STAGING_ADMIN_URL }}
          # Control temporal de sincronizaci√≥n de TypeORM (usar solo puntualmente y volver a false)
          TYPEORM_SYNC=${{ vars.TYPEORM_SYNC || 'false' }}
          EOF

      - name: 1. Prepare deployment info
        run: |
          echo "üöÄ Preparando deployment a staging..."
          echo "üì¶ Archivos listos para deploy:"
          ls -la deploy-staging.tar.gz .env.staging
          
          echo ""
          echo "üìã Informaci√≥n del deploy:"
          echo "- Branch: ${{ github.ref_name }}"
          echo "- Commit: ${{ github.sha }}"
          echo "- Target: ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }}"
          echo "- Path: /var/www/guiders-backend-staging/"

      - name: 2. Create staging directory
        env:
          SSH_PASSWORD: ${{ secrets.STAGING_SSH_PASSWORD }}
        run: |
          echo "üìÅ Creando directorio de staging..."
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} "mkdir -p /var/www/guiders-backend-staging/"
          echo "‚úÖ Directorio creado exitosamente"

      - name: 3. Upload main files
        env:
          SSH_PASSWORD: ${{ secrets.STAGING_SSH_PASSWORD }}
        run: |
          echo "üì§ Subiendo archivos principales..."
          sshpass -p "$SSH_PASSWORD" scp -o StrictHostKeyChecking=no deploy-staging.tar.gz .env.staging docker-compose-staging.yml ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }}:/var/www/guiders-backend-staging/
          echo "‚úÖ Archivos principales subidos"

      - name: 4. Upload scripts and utilities
        env:
          SSH_PASSWORD: ${{ secrets.STAGING_SSH_PASSWORD }}
        run: |
          echo "üì§ Subiendo scripts y utilidades..."
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} "mkdir -p /var/www/guiders-backend-staging/scripts/"
          sshpass -p "$SSH_PASSWORD" scp -o StrictHostKeyChecking=no scripts/mongo-init.js bin/test-mongodb-connection.js ecosystem.staging.config.js ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }}:/var/www/guiders-backend-staging/
          echo "‚úÖ Scripts subidos exitosamente"

      - name: 5. Extract and prepare application
        env:
          SSH_PASSWORD: ${{ secrets.STAGING_SSH_PASSWORD }}
        run: |
          echo "üì¶ Descomprimiendo aplicaci√≥n..."
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} '
            cd /var/www/guiders-backend-staging/
            
            echo "üì¶ Descomprimiendo aplicaci√≥n..."
            tar xzf deploy-staging.tar.gz
            
            # Usar package.json optimizado
            if [ -f package-staging.json ]; then
              mv package-staging.json package.json
              echo "‚úÖ Usando package.json optimizado para staging"
            fi
            
            echo "‚úÖ Aplicaci√≥n descomprimida exitosamente"
          '

      - name: 6. Install dependencies
        env:
          SSH_PASSWORD: ${{ secrets.STAGING_SSH_PASSWORD }}
        run: |
          echo "üì¶ Instalando dependencias de producci√≥n..."
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} '
            cd /var/www/guiders-backend-staging/
            
            # Instalar dependencias completas (incluye dev) para permitir build del script de migraciones
            rm -rf node_modules
            npm ci
            
            echo "‚úÖ Dependencias instaladas exitosamente"
          '

      - name: 7. Start database services
        env:
          SSH_PASSWORD: ${{ secrets.STAGING_SSH_PASSWORD }}
        run: |
          echo "üê≥ Iniciando servicios de base de datos..."
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} '
            cd /var/www/guiders-backend-staging/
            
            echo "üê≥ Iniciando servicios de base de datos..."
            docker compose -f docker-compose-staging.yml --env-file .env.staging up -d --remove-orphans
            
            echo "‚úÖ Servicios Docker iniciados"
          '

      - name: 8. Wait for services to be ready
        env:
          SSH_PASSWORD: ${{ secrets.STAGING_SSH_PASSWORD }}
        run: |
          echo "‚è≥ Esperando que los servicios est√©n listos..."
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} '
            cd /var/www/guiders-backend-staging/
            
            # Esperar a que est√©n listos
            echo "‚è≥ Esperando servicios..."
            for i in {1..12}; do
              echo "  Intento $i/12..."
              
              # Buscar contenedores con sufijo -staging
              postgres_ok=$(docker inspect --format="{{.State.Health.Status}}" postgres-staging 2>/dev/null | grep -c "healthy" || echo "0")
              mongodb_ok=$(docker inspect --format="{{.State.Health.Status}}" mongodb-staging 2>/dev/null | grep -c "healthy" || echo "0")
              redis_ok=$(docker inspect --format="{{.State.Health.Status}}" redis-staging 2>/dev/null | grep -c "healthy" || echo "0")
              
              echo "    PostgreSQL (postgres-staging): $([[ $postgres_ok -eq 1 ]] && echo "‚úÖ healthy" || echo "‚ùå not ready")"
              echo "    MongoDB (mongodb-staging): $([[ $mongodb_ok -eq 1 ]] && echo "‚úÖ healthy" || echo "‚ùå not ready")"
              echo "    Redis (redis-staging): $([[ $redis_ok -eq 1 ]] && echo "‚úÖ healthy" || echo "‚ùå not ready")"
              
              if [[ $postgres_ok -eq 1 && $mongodb_ok -eq 1 && $redis_ok -eq 1 ]]; then
                echo "  ‚úÖ Todas las bases de datos listas!"
                break
              fi
              
              if [[ $i -eq 12 ]]; then
                echo "  ‚ùå Timeout esperando servicios"
                echo "üîç Estado actual de los contenedores:"
                docker ps
                echo "üîç Logs de servicios que fallan:"
                [[ $postgres_ok -eq 0 ]] && echo "--- PostgreSQL logs ---" && docker logs postgres-staging --tail 20
                [[ $mongodb_ok -eq 0 ]] && echo "--- MongoDB logs ---" && docker logs mongodb-staging --tail 20
                [[ $redis_ok -eq 0 ]] && echo "--- Redis logs ---" && docker logs redis-staging --tail 20
                exit 1
              fi
              
              sleep 5
            done
          '

      - name: 9. Run database migrations
        env:
          SSH_PASSWORD: ${{ secrets.STAGING_SSH_PASSWORD }}
        run: |
          echo "üîÑ Ejecutando migraciones (modo simplificado)..."
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} '
            set -e
            cd /var/www/guiders-backend-staging
            export $(grep -v "^#" .env.staging | xargs)
            NODE_ENV=staging npx typeorm migration:run -d dist/src/data-source.js
          '

      - name: 10. Start application with PM2
        env:
          SSH_PASSWORD: ${{ secrets.STAGING_SSH_PASSWORD }}
        run: |
          echo "üöÄ Iniciando aplicaci√≥n de staging..."
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} '
            cd /var/www/guiders-backend-staging/
            
            # Crear directorio de logs de PM2 si no existe
            sudo mkdir -p /var/log/pm2
            sudo chown $USER:$USER /var/log/pm2
            
            # Reiniciar aplicaci√≥n usando el archivo ecosystem
            echo "üöÄ Iniciando aplicaci√≥n de staging con ecosystem config..."
            pm2 delete guiders-backend-staging 2>/dev/null || true
            
            # Usar el archivo ecosystem para gesti√≥n completa de variables de entorno
            pm2 start ecosystem.staging.config.js
            
            # Guardar configuraci√≥n PM2
            pm2 save
            
            echo "‚úÖ Aplicaci√≥n iniciada exitosamente"
          '

      - name: 11. Verify deployment status
        env:
          SSH_PASSWORD: ${{ secrets.STAGING_SSH_PASSWORD }}
        run: |
          echo "üìä Verificando estado del deployment..."
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} '
            cd /var/www/guiders-backend-staging/
            
            echo "‚úÖ Deployment completado!"
            echo ""
            echo "üìä Estado de PM2:"
            pm2 list | grep guiders-backend-staging
            echo ""
            echo "üìä Estado de Docker:"
            docker ps
          '

      - name: 12. Test MongoDB connection
        env:
          SSH_PASSWORD: ${{ secrets.STAGING_SSH_PASSWORD }}
        run: |
          echo "üîç Probando conexi√≥n a MongoDB..."
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} '
            cd /var/www/guiders-backend-staging/
            
            echo "üîç Probando conexi√≥n a MongoDB de staging..."
            # Cargar variables del archivo .env.staging y establecer NODE_ENV
            export $(grep -v "^#" .env.staging | xargs)
            export NODE_ENV=staging
            node test-mongodb-connection.js
            echo "‚úÖ Conexi√≥n a MongoDB verificada"
          '

      - name: 13. Final deployment verification
        env:
          SSH_PASSWORD: ${{ secrets.STAGING_SSH_PASSWORD }}
        run: |
          echo "üîç Verificaci√≥n final del deployment..."
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} '
            cd /var/www/guiders-backend-staging/
            
            echo "üìä Estado final de staging:"
            echo ""
            echo "üü¢ PM2 Processes:"
            pm2 list
            echo ""
            echo "üê≥ Docker Containers:"
            docker ps
            echo ""
            echo "üíæ Disk Usage:"
            du -sh /var/www/guiders-backend-staging/
            echo ""
            echo "üåê Network Ports:"
            netstat -tulpn | grep -E ":3000|:5432|:27017|:6379" || echo "Puerto no encontrado en netstat"
            
            echo ""
            echo "‚úÖ ¬°Deployment de staging verificado exitosamente!"
          '

  # Resumen final
  summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [test-and-build, deploy-staging]
    if: always()
    
    steps:
      - name: Show results
        run: |
          echo "# üìä Resumen de Staging Deploy" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Tests:** ${{ needs.test-and-build.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deploy:** ${{ needs.deploy-staging.result }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.deploy-staging.result }}" == "success" ]]; then
            echo "## ‚úÖ Deploy Exitoso" >> $GITHUB_STEP_SUMMARY
            echo "Staging desplegado exitosamente con secrets configurados" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### üåê URLs de Staging:" >> $GITHUB_STEP_SUMMARY
            echo "- App: https://staging.guiders.app" >> $GITHUB_STEP_SUMMARY
            echo "- API: https://staging-api.guiders.app" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### ÔøΩ Servicios activos:" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ PostgreSQL (Base de datos principal)" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ MongoDB (Mensajes cifrados)" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ Redis (Cache y sesiones)" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ PM2 (guiders-backend-staging)" >> $GITHUB_STEP_SUMMARY
          else
            echo "## ‚ùå Deploy Fallido" >> $GITHUB_STEP_SUMMARY
            echo "Revisar logs para m√°s detalles" >> $GITHUB_STEP_SUMMARY
          fi
