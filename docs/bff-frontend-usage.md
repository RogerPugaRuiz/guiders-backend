# Gu√≠a de Uso: BFF con Cookies HttpOnly para SPA Frontend

## üìã Resumen

Esta gu√≠a explica c√≥mo utilizar la nueva estrategia BFF (Backend For Frontend) con cookies HttpOnly desde tu aplicaci√≥n SPA (Single Page Application) de frontend.

## üéØ ¬øQu√© es el BFF con Cookies HttpOnly?

El BFF es una capa intermedia que:
- Maneja la autenticaci√≥n con Keycloak autom√°ticamente
- Almacena tokens JWT en cookies HttpOnly (inaccesibles desde JavaScript)
- Proporciona endpoints simples para login/logout/refresh
- Mejora la seguridad contra ataques XSS

## üîß Configuraci√≥n Frontend

### 1. Configuraci√≥n de Fetch/Axios

**IMPORTANTE**: Siempre incluir `credentials: 'include'` en todas las peticiones:

```javascript
// Con fetch nativo
fetch('/api/bff/auth/login', {
  method: 'POST',
  credentials: 'include', // ‚Üê Esencial para cookies
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    username: 'usuario@ejemplo.com',
    password: 'password123'
  })
});

// Con axios (configuraci√≥n global recomendada)
axios.defaults.withCredentials = true;

// O por petici√≥n individual
axios.post('/api/bff/auth/login', {
  username: 'usuario@ejemplo.com',
  password: 'password123'
}, {
  withCredentials: true
});
```

### 2. Configuraci√≥n CORS del Frontend

Aseg√∫rate de que tu servidor de desarrollo est√© configurado correctamente:

```javascript
// webpack.config.js o similar
module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: 'http://localhost:3000',
        changeOrigin: true,
        credentials: true // ‚Üê Para cookies
      }
    }
  }
};

// O con Vite (vite.config.js)
export default {
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:3000',
        changeOrigin: true
      }
    }
  }
};
```

## üöÄ Endpoints Disponibles

### POST `/api/bff/auth/login`
Autentica al usuario y establece cookies HttpOnly.

```javascript
const login = async (username, password) => {
  try {
    const response = await fetch('/api/bff/auth/login', {
      method: 'POST',
      credentials: 'include',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ username, password })
    });

    const data = await response.json();
    
    if (data.success) {
      console.log('Login exitoso:', data.user);
      // Las cookies se configuran autom√°ticamente
      return data.user;
    } else {
      throw new Error('Login fallido');
    }
  } catch (error) {
    console.error('Error en login:', error);
    throw error;
  }
};
```

### POST `/api/bff/auth/refresh`
Renueva autom√°ticamente el access token usando el refresh token de la cookie.

```javascript
const refreshToken = async () => {
  try {
    const response = await fetch('/api/bff/auth/refresh', {
      method: 'POST',
      credentials: 'include',
    });

    const data = await response.json();
    return data.success;
  } catch (error) {
    console.error('Error renovando token:', error);
    return false;
  }
};
```

### GET `/api/bff/auth/me`
Obtiene informaci√≥n del usuario autenticado.

```javascript
const getCurrentUser = async () => {
  try {
    const response = await fetch('/api/bff/auth/me', {
      method: 'GET',
      credentials: 'include',
    });

    if (response.ok) {
      const data = await response.json();
      return data.user;
    } else {
      return null; // No autenticado
    }
  } catch (error) {
    console.error('Error obteniendo usuario:', error);
    return null;
  }
};
```

### POST `/api/bff/auth/logout`
Cierra la sesi√≥n y limpia las cookies.

```javascript
const logout = async () => {
  try {
    const response = await fetch('/api/bff/auth/logout', {
      method: 'POST',
      credentials: 'include',
    });

    const data = await response.json();
    
    if (data.success) {
      console.log('Logout exitoso');
      // Redirigir a login o limpiar estado
      return true;
    }
  } catch (error) {
    console.error('Error en logout:', error);
  }
  return false;
};
```

## üîí Peticiones Autenticadas a Otros Endpoints

Para todas las dem√°s peticiones API que requieren autenticaci√≥n:

```javascript
// Ejemplo: Obtener datos protegidos
const fetchProtectedData = async () => {
  try {
    const response = await fetch('/api/protected-endpoint', {
      method: 'GET',
      credentials: 'include', // ‚Üê Las cookies se env√≠an autom√°ticamente
      headers: {
        'Content-Type': 'application/json',
      }
    });

    if (response.status === 401) {
      // Token expirado, intentar renovar
      const refreshed = await refreshToken();
      if (refreshed) {
        // Reintentar la petici√≥n original
        return fetchProtectedData();
      } else {
        // Redirigir a login
        window.location.href = '/login';
        return;
      }
    }

    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Error en petici√≥n protegida:', error);
    throw error;
  }
};
```

## ‚ö° Implementaci√≥n en React/Vue/Angular

### React Context para Autenticaci√≥n

```jsx
import React, { createContext, useContext, useEffect, useState } from 'react';

const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  // Verificar autenticaci√≥n al cargar
  useEffect(() => {
    checkAuth();
  }, []);

  const checkAuth = async () => {
    try {
      const currentUser = await getCurrentUser();
      setUser(currentUser);
    } catch (error) {
      setUser(null);
    } finally {
      setLoading(false);
    }
  };

  const login = async (username, password) => {
    try {
      const response = await fetch('/api/bff/auth/login', {
        method: 'POST',
        credentials: 'include',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, password })
      });

      const data = await response.json();
      
      if (data.success) {
        setUser(data.user);
        return true;
      } else {
        throw new Error('Login fallido');
      }
    } catch (error) {
      console.error('Error en login:', error);
      return false;
    }
  };

  const logout = async () => {
    try {
      await fetch('/api/bff/auth/logout', {
        method: 'POST',
        credentials: 'include',
      });
      setUser(null);
    } catch (error) {
      console.error('Error en logout:', error);
    }
  };

  return (
    <AuthContext.Provider value={{ user, login, logout, loading }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth debe usarse dentro de AuthProvider');
  }
  return context;
};
```

### Interceptor HTTP Axios

```javascript
import axios from 'axios';

// Configuraci√≥n global
axios.defaults.baseURL = 'http://localhost:3000';
axios.defaults.withCredentials = true;

// Interceptor para renovaci√≥n autom√°tica
axios.interceptors.response.use(
  (response) => response,
  async (error) => {
    const original = error.config;
    
    if (error.response?.status === 401 && !original._retry) {
      original._retry = true;
      
      try {
        // Intentar renovar token
        await axios.post('/api/bff/auth/refresh');
        
        // Reintentar petici√≥n original
        return axios(original);
      } catch (refreshError) {
        // Renovaci√≥n fall√≥, redirigir a login
        window.location.href = '/login';
        return Promise.reject(refreshError);
      }
    }
    
    return Promise.reject(error);
  }
);
```

## üîß Interceptor para Fetch

```javascript
// Wrapper para fetch con renovaci√≥n autom√°tica
const authenticatedFetch = async (url, options = {}) => {
  const defaultOptions = {
    credentials: 'include',
    ...options
  };

  let response = await fetch(url, defaultOptions);

  // Si recibimos 401, intentar renovar
  if (response.status === 401) {
    const refreshResponse = await fetch('/api/bff/auth/refresh', {
      method: 'POST',
      credentials: 'include',
    });

    if (refreshResponse.ok) {
      // Token renovado, reintentar petici√≥n original
      response = await fetch(url, defaultOptions);
    } else {
      // Renovaci√≥n fall√≥, redirigir a login
      window.location.href = '/login';
      throw new Error('Sesi√≥n expirada');
    }
  }

  return response;
};

// Uso
const data = await authenticatedFetch('/api/protected-endpoint');
```

## üö´ Lo que NO debes hacer

### ‚ùå No almacenar tokens en localStorage
```javascript
// MAL - Ya no necesario
localStorage.setItem('access_token', token);

// BIEN - Las cookies se manejan autom√°ticamente
// No necesitas hacer nada especial
```

### ‚ùå No agregar headers Authorization manualmente
```javascript
// MAL - Ya no necesario
const response = await fetch('/api/endpoint', {
  headers: {
    'Authorization': `Bearer ${token}` // ‚Üê No necesario
  }
});

// BIEN - Solo incluir credentials
const response = await fetch('/api/endpoint', {
  credentials: 'include' // ‚Üê Suficiente
});
```

### ‚ùå No olvidar credentials: 'include'
```javascript
// MAL - Las cookies no se env√≠an
fetch('/api/endpoint');

// BIEN - Las cookies se incluyen
fetch('/api/endpoint', { credentials: 'include' });
```

## üîç Debugging

### Verificar Cookies en DevTools
1. Abre las DevTools (F12)
2. Ve a la pesta√±a "Application" (Chrome) o "Storage" (Firefox)
3. Selecciona "Cookies" en el panel izquierdo
4. Deber√≠as ver:
   - `access_token` (con HttpOnly marcado)
   - `refresh_token` (con HttpOnly marcado)

### Verificar Peticiones de Red
1. Ve a la pesta√±a "Network"
2. Realiza una petici√≥n autenticada
3. En la petici√≥n, verifica:
   - Header "Cookie" debe incluir los tokens
   - Si es una respuesta de login, "Set-Cookie" debe estar presente

## ‚ö†Ô∏è Consideraciones de Seguridad

1. **HTTPS en Producci√≥n**: Las cookies HttpOnly requieren HTTPS para m√°xima seguridad
2. **SameSite**: Las cookies est√°n configuradas con `SameSite=Strict`
3. **Dominios**: Aseg√∫rate de que frontend y backend est√©n en el mismo dominio en producci√≥n
4. **CSP**: Configura Content Security Policy adecuadamente

## üöÄ Migraci√≥n desde JWT en Headers

Si vienes de una implementaci√≥n con JWT en headers:

```javascript
// ANTES: Con JWT en headers
const oldApiCall = async () => {
  const token = localStorage.getItem('access_token');
  
  const response = await fetch('/api/endpoint', {
    headers: {
      'Authorization': `Bearer ${token}`
    }
  });
  
  return response.json();
};

// DESPU√âS: Con BFF y cookies HttpOnly
const newApiCall = async () => {
  const response = await fetch('/api/endpoint', {
    credentials: 'include' // ‚Üê Solo este cambio necesario
  });
  
  return response.json();
};
```

## üéâ Beneficios Obtenidos

- ‚úÖ **Seguridad mejorada**: Tokens inaccesibles desde JavaScript
- ‚úÖ **Simplicidad**: No gesti√≥n manual de tokens
- ‚úÖ **Renovaci√≥n autom√°tica**: Sin interrupciones para el usuario
- ‚úÖ **Menos c√≥digo**: Eliminaci√≥n de l√≥gica de manejo de tokens
- ‚úÖ **Anti-XSS**: Protecci√≥n nativa contra scripts maliciosos

## üÜò Troubleshooting

### Problema: Las cookies no se env√≠an
**Soluci√≥n**: Verificar `credentials: 'include'` en todas las peticiones

### Problema: CORS errors
**Soluci√≥n**: Verificar configuraci√≥n de CORS en backend y proxy en frontend

### Problema: 401 constantes
**Soluci√≥n**: Verificar que el endpoint `/api/bff/auth/refresh` funcione correctamente

### Problema: Cookies no aparecen en DevTools
**Soluci√≥n**: Verificar que el backend est√© enviando headers `Set-Cookie` correctos

¬øNecesitas ayuda adicional? Revisa los logs del backend o contacta al equipo de desarrollo.